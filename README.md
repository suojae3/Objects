---

## 오브젝트 - 조영호

#

### [Chapter 01] 객체, 설계 <br/>

1. 이해가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. <br/> 
2. 우리의 목표는 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다. <br/>
3. 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다. 캡슐화를 통해 객체내부로 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다. <br/>
4. 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다. <br/>
5. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다. <br/>
6. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다. <br/>
7. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다. <br/>
8. 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 따라서 좋은 코드를 작성하고 싶다면 차라리 한 편의 애니메이션을 만든다고 생각해라. <br/>
9. 설계란 코드를 배치하는 것이다. <br/>
10. 변경가능한 코드란 이해하기 쉬운 코드다. <br/>
11. 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다. 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다. <br/>

---

#

### [Chapter 02] 객체지향 프로그래밍 <br/>

1. 대부분 사람들은 클래스를 결정한 후에 어떤 속성과 메서드가 필요한지 고민한다. 안타깝게도 이것은 객체지향의 본질과는 거리가 멀다. 진정한 객체지향 패러다임은 클래스가 아닌 객체에 초점을 맞추어야 한다.  <br/>
2.  어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라 <br/>
3. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. <br/>
4. 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다. <br/>
5. 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야한다. 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다. <br/>
6. 여기서 주목할 점은 인스턴스 변수의 가시성은 `private` 이고 메서드의 가시성은 `public` 이라는  것이다.  <br/>
7. 클래스의 내부와 외부를 구분해야하는 이유는 무엇일까?  그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. <br/> 
8. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송, 수신하는 것뿐이다. <br/>
9. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다. 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부른다. <br/>
10. 오버라이딩은 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 가리킨다. 자식클래스의 메서드는 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 외부에서는 부모 클래스의 메서드가 보이지 않는다. <br/>
11. 오버로딩은 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다. 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 이 메서드들은 사이좋게 공존한다. <br/>
12. 생성자의 파라미터 목록을 이요해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할 수 있다.  <br/>
13. 여러분이 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다. 이것이 객체지향 설계가 어려우면서도 매력적인 이유다 <br/>
